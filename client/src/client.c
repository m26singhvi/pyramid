#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include "tlv.h"
#include "common.h" // FIXME: take care of relative addressing
#include "cli_commands.h"

extern int inet_aton(const char *cp, struct in_addr *inp);

static void send_data(int fd);
static void send_joining_groups(int fd, uint32_t *groups, int numgroups);

enum client_error_msgs {
    CL_INVALID_IP,
    CL_INVALID_PORT,
    CL_LAST /* Should be always last */
};

/*
 * client_print_usage ()
 *
 * Print the command usage in case a wrong command was issued.
 */
static inline void
client_print_usage (void)
{
    printf("Usage: client <server ip> <server port> group-ids...\n");
}

/*
 * client_print_error_msgs ()
 *
 * Print the error messages generated by the client.
 */
static void
client_print_error_msgs (enum client_error_msgs error, char *msg)
{
    switch(error) {
    case CL_INVALID_IP:
	printf("Invalid IP address %s\n", msg);
	client_print_usage();
	break;
    case CL_INVALID_PORT:
	printf("Invalid port number %s\n", msg);
	client_print_usage();
	break;
    default:
	break;
    }
}

/*
 * client_input_sanity_check ()
 *
 * Verifies that the command line args passed are appropriate or not.
 * If sucessfully verified the server IP and port is stored in
 * sip and sp, respectively.
 */
static enum boolean 
client_input_sanity_check (int argc,
			   char *argv[],
			   in_addr_t *sip,
			   in_port_t *sp)
{
    struct in_addr addr;
    int port = 0;
    char *as = argv[1];
    char *ps = argv[2];
    printf("Address : %s\n", as);
    printf("Port : %s\n", ps);

    int i = 0;

    if (argc <= 3) {
	client_print_usage();
	return FALSE;
    }

    // Check if the address is well formed IP Address or not
    if (inet_aton(as, &addr) == 0) {
	client_print_error_msgs(CL_INVALID_IP, as);
	return FALSE;
    }
    *sip = addr.s_addr;

    while (ps[i]) {
	if (!isdigit(ps[i])) {
	    client_print_error_msgs(CL_INVALID_PORT, ps);
	    return FALSE;
	}
	i++;
    }
    port = atoi(ps);
    if (port > USHRT_MAX) {
	client_print_error_msgs(CL_INVALID_PORT, ps);
	return FALSE;
    }
    *sp = htons(port);

    return TRUE;
}

static inline int
client_create_tcp_socket (void)
{
    int fd = 0;

    fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd == -1) {
	report_error_and_terminate("Failed to create socket");
    }
    return fd;
}

static inline void
client_close_fd (int fd)
{
    if (close(fd) == -1) {
	perror(__FUNCTION__);
    }
}

void
client_connect (int cfd, in_addr_t sip, in_port_t sp)
{

    struct sockaddr_in server_s_addr;

    memset(&server_s_addr, 0, sizeof(server_s_addr));
    IPV4_SOCKADDR(server_s_addr, AF_INET, sp, sip);

    if (connect(cfd, (struct sockaddr *) &server_s_addr,
	sizeof(server_s_addr)) == -1) {
	perror("Failed to connect");
	client_close_fd(cfd);
	exit(EXIT_FAILURE);
    }

}

int
main (int argc, char* argv[])
{
    int client_s_fd;
    in_addr_t sip = 0;
    in_port_t sp = 0;

    // TODO: Create keep alive thread. See if this can be merged with the client thread

    // Sanity check the command line inputs.
    if (client_input_sanity_check(argc, argv, &sip, &sp) == FALSE) {
	exit(EXIT_FAILURE);
    }
 
    client_s_fd = client_create_tcp_socket();
    client_connect(client_s_fd, sip, sp);
    
    if(argc == 4 && !strcmp(argv[3], "CLI"))
    {
	cli_main();
	return 0;
    }

    int numgroups = 0;
    uint32_t groups[255];
    for (int i = 0 ; i < (argc-3); i++) 
    {
      groups[i] = atoi(argv[i+3]);
      numgroups = numgroups + 1;
    }
    send_joining_groups (client_s_fd, groups, numgroups);
      
    // Take user input and send it to server
    send_data(client_s_fd);

    client_close_fd(client_s_fd);

    return 0;
}

/*
 * send_data ()
 *
 * This is a temp func for testing.
 */
static void
send_data (int fd)
{
    char buffer[ONE_KB];

    while (fgets(buffer, sizeof(buffer), stdin) != NULL) {
	int len = strlen(buffer);
	int sent = 0;
	while (len > 0) {
            Buffer buf;
            char payload[1024];
            memset(payload, 0, 1024);
            buf.payload = &payload;
            buf.length = 0;
            int encoded_len = encode(STRING_DATA, (void *)buffer , len, &buf);
	    if ((sent = send(fd, payload, encoded_len, 0)) == -1) {
		report_error_and_terminate("Failed to send data");
	    } else {
		len -= sent;
	    }
	}
    }
}

/*
 * send_joining_groups ()
 *
 * This is a temp func for testing.
 */
static void
send_joining_groups (int fd, uint32_t *groups, int numgroups)
{
    int sent = 0;
    Buffer buf;
    char payload[1024];
    memset(payload, 0, 1024);
    buf.payload = &payload;
    buf.length = 0;
    int encoded_len = encode(JOIN_GROUP, (void *)groups, numgroups, &buf);
	   
     if ((sent = send(fd, buf.payload, encoded_len, 0)) == -1) 
        report_error_and_terminate("Failed to send data");
     else
       printf("Joining Groups Sent");
}


