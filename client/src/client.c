#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include "tlv.h"
#include "common.h" // FIXME: take care of relative addressing
#include "cli_commands.h"
#include "api.h"

extern int inet_aton(const char *cp, struct in_addr *inp);

void receive_exec_request (int server_fd);
static void send_data(int fd, char *buffer, int ALGO);
static void send_joining_groups(int fd, uint32_t *groups, int numgroups);

enum client_error_msgs {
    CL_INVALID_IP,
    CL_INVALID_PORT,
    CL_LAST /* Should be always last */
};

/*
 * client_print_usage ()
 *
 * Print the command usage in case a wrong command was issued.
 */
static inline void
client_print_usage (void)
{
    printf("Usage: client <server ip> <server port> group-ids...\n");
}

/*
 * client_print_error_msgs ()
 *
 * Print the error messages generated by the client.
 */
static void
client_print_error_msgs (enum client_error_msgs error, char *msg)
{
    switch(error) {
    case CL_INVALID_IP:
	printf("Invalid IP address %s\n", msg);
	client_print_usage();
	break;
    case CL_INVALID_PORT:
	printf("Invalid port number %s\n", msg);
	client_print_usage();
	break;
    default:
	break;
    }
}

/*
 * client_input_sanity_check ()
 *
 * Verifies that the command line args passed are appropriate or not.
 * If sucessfully verified the server IP and port is stored in
 * sip and sp, respectively.
 */
static enum boolean 
client_input_sanity_check (int argc,
			   char *argv[],
			   in_addr_t *sip,
			   in_port_t *sp)
{
    struct in_addr addr;
    int port = 0;
    char *as = argv[1];
    char *ps = argv[2];
    printf("Address : %s\n", as);
    printf("Port : %s\n", ps);

    int i = 0;

    if (argc <= 3) {
	client_print_usage();
	return FALSE;
    }

    // Check if the address is well formed IP Address or not
    if (inet_aton(as, &addr) == 0) {
	client_print_error_msgs(CL_INVALID_IP, as);
	return FALSE;
    }
    *sip = addr.s_addr;

    while (ps[i]) {
	if (!isdigit(ps[i])) {
	    client_print_error_msgs(CL_INVALID_PORT, ps);
	    return FALSE;
	}
	i++;
    }
    port = atoi(ps);
    if (port > USHRT_MAX) {
	client_print_error_msgs(CL_INVALID_PORT, ps);
	return FALSE;
    }
    *sp = htons(port);

    return TRUE;
}

static inline int
client_create_tcp_socket (void)
{
    int fd = 0;

    fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd == -1) {
	report_error_and_terminate("Failed to create socket");
    }
    return fd;
}

static inline void
client_close_fd (int fd)
{
    if (close(fd) == -1) {
	perror(__FUNCTION__);
    }
}

void
client_connect (int cfd, in_addr_t sip, in_port_t sp)
{

    struct sockaddr_in server_s_addr;

    memset(&server_s_addr, 0, sizeof(server_s_addr));
    IPV4_SOCKADDR(server_s_addr, AF_INET, sp, sip);

    if (connect(cfd, (struct sockaddr *) &server_s_addr,
	sizeof(server_s_addr)) == -1) {
	perror("Failed to connect");
	client_close_fd(cfd);
	exit(EXIT_FAILURE);
    }

}

int
main (int argc, char* argv[])
{
    int client_s_fd;
    in_addr_t sip = 0;
    in_port_t sp = 0;

    // TODO: Create keep alive thread. See if this can be merged with the client thread

    // Sanity check the command line inputs.
    if (client_input_sanity_check(argc, argv, &sip, &sp) == FALSE) {
	exit(EXIT_FAILURE);
    }
 
    client_s_fd = client_create_tcp_socket();
    client_connect(client_s_fd, sip, sp);
    
    if(argc == 4 && !strcmp(argv[3], "CLI"))
    {
	cli_main(client_s_fd);
    } else {

        int numgroups = 0;
        uint32_t groups[255];
        for (int i = 0 ; i < (argc-3); i++) 
        {
           groups[i] = atoi(argv[i+3]);
           numgroups = numgroups + 1;
        }
        send_joining_groups (client_s_fd, groups, numgroups);
        printf("\nWaiting for task from server"); 
        // Take user input and send it to server
        //send_data(client_s_fd);
        
	//Receive task from user and send back result
	receive_exec_request(client_s_fd);
        printf("\nDone Request");
    }	
    client_close_fd(client_s_fd);

    return 0;
}

static void 
handle_exec_data(int server_fd, Tlv tlv)
{
   switch(tlv.type)
   {
        case ALGO_MAX:
	{
	    //CALL MAX API
            if(main_api(tlv.value, "output.txt", FIND_MAX) == API_SUCCESS){
                send_data(server_fd, "MAXResult", ALGO_MAX);
            } else {
                send_data(server_fd, "\nClientErrorType\n", ALGO_ERROR);
            }

	    send_data(server_fd, "\nMAX Request received at client.\n", ALGO_MAX);
	    printf("\nRequest Recevied to find max in a file\n");
	    break;
	}
        case ALGO_SORT:
	{
	    printf("\nRequest Received to sort a File\n");
	    break;
	}
        default :
     	   printf("%s : unknown Attribute, can't handle ", __func__);
        break;
   }
}


/*
 * receive_data ()
 *
 */
void  
receive_exec_request (int server_fd)
{
    printf("\nReceive data from fd %d\n", server_fd);
    int done = 0;

    while (1)
    {
        ssize_t count;
        char buf[ONE_KB];
        int flags = 0;

        count = recv(server_fd, buf, sizeof buf, flags);
        buf[count] = '\0';
        if (count == -1)
        {
            /* If errno == EAGAIN, that means we have read all
             * data. So go back to the main loop. */
            if (errno != EAGAIN)
            {
                perror ("read");
                done = 1;
            }
            break;
        }
        else if (count == 0)
        {
            /* End of file. The remote has closed the
             * connection. */
            done = 1;
            break;
        }
        printf("Got some data on an existing fd %d\n",server_fd);
        Tlv tlv = decode(buf, count);
        handle_exec_data(server_fd, tlv);
        /* Write the buffer to standard output */
        /*int s = write (1, tlv.value, tlv.length);
        printf("\nA.");
        if (s == -1)
        {
            perror ("write");
            abort ();
        }*/
    }

    if (done)
    {
        printf("No data on descriptor %d\n", server_fd);

    }
}


/*
 * send_data ()
 *
 * This is a temp func for testing.
 */
static void
send_data (int fd, char *buffer, int ALGO)
{
	int len = strlen(buffer);
	int sent = 0;
	while (len > 0) {
            Buffer buf;
            char payload[1024];
            memset(payload, 0, 1024);
            buf.payload = payload;
            buf.length = 0;
            int encoded_len = encode(ALGO, (void *)buffer , len, &buf);
	    if ((sent = send(fd, payload, encoded_len, 0)) == -1) {
		report_error_and_terminate("Failed to send data");
	    } else {
		len -= sent;
	    }
	}
}

/*
 * send_joining_groups ()
 *
 * This is a temp func for testing.
 */
static void
send_joining_groups (int fd, uint32_t *groups, int numgroups)
{
    int sent = 0;
    Buffer buf;
    char payload[1024];
    memset(payload, 0, 1024);
    buf.payload = payload;
    buf.length = 0;
    int encoded_len = encode(JOIN_GROUP, (void *)groups, numgroups, &buf);
	   
     if ((sent = send(fd, buf.payload, encoded_len, 0)) == -1) 
        report_error_and_terminate("Failed to send data");
     else
       printf("Joining Groups Sent\n");
}


